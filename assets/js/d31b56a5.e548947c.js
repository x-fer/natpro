"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4002],{1814:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/kondenzacija-0573f7490e17f03cdbc07f16d0c88537.png"},2313:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>j,frontMatter:()=>r,metadata:()=>m,toc:()=>c});var s=a(4848),i=a(8453),o=a(6749);a(9630);const r={title:"Kosarajuev algoritam"},t=void 0,m={id:"algoritmi-nad-grafovima-2/kosarajuev-algoritam",title:"Kosarajuev algoritam",description:"Definicija",source:"@site/docs/algoritmi-nad-grafovima-2/kosarajuev-algoritam.md",sourceDirName:"algoritmi-nad-grafovima-2",slug:"/algoritmi-nad-grafovima-2/kosarajuev-algoritam",permalink:"/docs/algoritmi-nad-grafovima-2/kosarajuev-algoritam",draft:!1,unlisted:!1,editUrl:"https://github.com/x-fer/natpro/edit/main/docs/algoritmi-nad-grafovima-2/kosarajuev-algoritam.md",tags:[],version:"current",frontMatter:{title:"Kosarajuev algoritam"},sidebar:"materijaliSidebar",previous:{title:"Topolo\u0161ko sortiranje",permalink:"/docs/algoritmi-nad-grafovima-2/topolosko-sortiranje"},next:{title:"2SAT",permalink:"/docs/algoritmi-nad-grafovima-2/2SAT"}},l={},c=[{value:"Definicija",id:"definicija",level:3},{value:"Algoritam",id:"algoritam",level:3},{value:"Implementacija",id:"implementacija",level:3},{value:"Odnosi izme\u0111u strogo povezanih komponenata",id:"odnosi-izme\u0111u-strogo-povezanih-komponenata",level:3}];function d(e){const n={annotation:"annotation",code:"code",em:"em",h3:"h3",img:"img",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.A,{authorName:"Martin Josip Kocijan",githubUsername:"kocijan"}),"\n",(0,s.jsx)(n.h3,{id:"definicija",children:"Definicija"}),"\n",(0,s.jsxs)(n.p,{children:["Za neki usmjereni graf ka\u017eemo da je ",(0,s.jsx)(n.strong,{children:"strogo povezan"})," (engl. ",(0,s.jsx)(n.em,{children:"strongly connected"}),") ako postoji put izme\u0111u svaka dva vrha. Ako su ",(0,s.jsx)(n.em,{children:"u"})," i ",(0,s.jsx)(n.em,{children:"v"})," razli\u010diti vrhovi, tada postoji put od ",(0,s.jsx)(n.em,{children:"u"})," do ",(0,s.jsx)(n.em,{children:"v"})," te postoji put od ",(0,s.jsx)(n.em,{children:"v"})," do ",(0,s.jsx)(n.em,{children:"u"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Usmjerene grafove mo\u017eemo rastaviti na disjunktne ",(0,s.jsx)(n.strong,{children:"strogo povezane komponente"})," (engl. ",(0,s.jsx)(n.em,{children:"strongly connected components"}),") gdje je svaka komponenta neki podgraf koji je strogo povezan."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Primjer strogo povezanih komponenata u usmjerenom grafu",src:a(8144).A+"",width:"2560",height:"1212"})}),"\n",(0,s.jsxs)(n.p,{children:["Na slici je primjer usmjerenog grafa kojem su ozna\u010dene njegove strogo povezane komponente. One su ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,s.jsx)(n.mi,{children:"a"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"b"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"e"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"}"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\{a, b, e\\}"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mopen",children:"{"}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"a"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"b"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"e"}),(0,s.jsx)(n.span,{className:"mclose",children:"}"})]})})]}),", ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,s.jsx)(n.mi,{children:"c"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"d"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"h"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"}"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\{c, d, h\\}"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mopen",children:"{"}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"c"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"h"}),(0,s.jsx)(n.span,{className:"mclose",children:"}"})]})})]})," i ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,s.jsx)(n.mi,{children:"f"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mi,{children:"g"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"}"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\{f, g\\}"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mopen",children:"{"}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,s.jsx)(n.span,{className:"mclose",children:"}"})]})})]}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"algoritam",children:"Algoritam"}),"\n",(0,s.jsx)(n.p,{children:"Kosarajuev algoritam zapo\u010dinje topolo\u0161kim sortiranjem vrhova usmjerenog grafa. Nakon toga pronalazimo strogo povezane komponente."}),"\n",(0,s.jsxs)(n.p,{children:["Potrebno je napisati dva DFS-a. Prvi slu\u017ei za generiranje topolo\u0161kog poretka koji spremamo u neku listu. Zatim prvo promijenimo smjer svim bridovima u grafu. Prema prethodno dobivenom topolo\u0161kom poretku nekom \u010dvoru ",(0,s.jsx)(n.em,{children:"x"})," u njegovu komponentu rekurzivno pridru\u017eujemo sve \u010dvorove do kojih postoji put od ",(0,s.jsx)(n.em,{children:"x"}),". Preciznije, u glavnom programu petljom prolazimo po svim \u010dvorovima ",(0,s.jsx)(n.em,{children:"u"})," prema topolo\u0161kom poretku. Za svaki \u010dvor ",(0,s.jsx)(n.em,{children:"u"})," zovemo ",(0,s.jsx)(n.code,{children:"dfs2(u, u)"}),". Rekurzija ",(0,s.jsx)(n.code,{children:"dfs2(x, y)"})," prvo provjerava je li \u010dvoru ",(0,s.jsx)(n.em,{children:"x"})," ve\u0107 obra\u0111en, odnosno je li mu ve\u0107 pridru\u017eena neka komponenta. Ako nije, \u010dvor ",(0,s.jsx)(n.em,{children:"x"})," pridru\u017euje se onoj komponenti u kojoj je ve\u0107 ",(0,s.jsx)(n.em,{children:"y"}),". Nakon toga u rekurziji prolazimo petljom po svim susjedima ",(0,s.jsx)(n.em,{children:"v"})," od ",(0,s.jsx)(n.em,{children:"x"})," te zovemo ",(0,s.jsx)(n.code,{children:"dfs2(v, y)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Algoritam je linearne slo\u017eenosti, odnosno ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"N"}),(0,s.jsx)(n.mo,{children:"+"}),(0,s.jsx)(n.mi,{children:"M"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(N+M)"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"+"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"M"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"implementacija",children:"Implementacija"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define N 200200\n \nint n, m;\nint u, v;\nvector<int> g[N];\n// ako imamo matricu susjedstva, mo\u017eemo dobiti inverz i tako da ju transponiramo\nvector<int> g_inv[N];\nint bio[N];\nstack<int> topo;\n// ovdje zapisujemo rje\u0161enje, tako da su dva vrha x i y u istoj komponenti ako je comp[x] == comp[y]\n// mogli smo rje\u0161enje zapisati i u bio[] samo treba paziti na brojeve koji ozna\u010davaju komponente i broj koji ozna\u010dava neposje\u0107eni \u010dvor\nint comp[N];\n \nvoid dfs1(int cv)\n{\n  if (bio[cv]) return;\n  bio[cv] = 1;\n  for (int i: g[cv]) {\n    dfs1(i);\n  }\n  topo.push(cv);\n}\n \nvoid dfs2(int cv, int root)\n{\n  if (bio[cv]) return;\n  bio[cv] = 1;\n  // comp[cv] = comp[root]\n  comp[cv] = root;\n  // svim bridovima trebamo zamijeniti smjer pa nas ne zanimaju izlazni nego ulazni bridovi\n  for (int i: g_inv[cv]) {\n    dfs2(i, root);\n  }\n}\n \nint main()\n{\n  scanf("%d%d", &n, &m);\n  for (int i = 0; i < m; i++) {\n    scanf("%d%d", &u, &v);\n    // zapisujemo da \u010dvor u ima izlazni brid prema v\n    g[u].pb(v);\n    // zapisujemo da \u010dvor v ima ulazni brid iz u\n    g_inv[v].pb(u);\n  }\n  for (int i = 0; i < n; i++) {\n    dfs1(i);\n  }\n  // mo\u017eemo reciklirati polje bio[]\n  memset(bio, 0, sizeof bio);\n  for (int i = 0; i < n; i++) {\n    int cv = topo.top();\n    topo.pop();\n    dfs2(cv, cv);\n  }\n  // za svaki \u010dvor ispisujemo kojoj komponenti on pripada\n  // vrijedi comp[x] == comp[y] ako i samo ako se x i y nalaze u istoj strogo povezanoj komponenti\n  for (int i = 0; i < n; i++) {\n    printf("%d\\n", comp[i]);\n  }\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"odnosi-izme\u0111u-strogo-povezanih-komponenata",children:"Odnosi izme\u0111u strogo povezanih komponenata"}),"\n",(0,s.jsx)(n.p,{children:"Svaki usmjereni graf mo\u017eemo kondenzirati u usmjereni graf bez ciklusa tako da svaku njegovu strogo povezanu komponentu stegnemo u jedan vrh."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Primjer kondenzacije strogo povezanih komponenata u nekom usmjerenom grafu",src:a(1814).A+"",width:"2560",height:"1607"})}),"\n",(0,s.jsx)(n.p,{children:"Na slici je primjer kondenzacije plavog usmjerenog grafa u \u017euti. Dok plavi ima cikluse, \u017euti ih nema. Svaka strogo povezana komponenta plavog grafa predstavljena je jednim \u017eutim vrhom. Ako iz nekog vrha u jednoj plavoj komponenti postoji brid prema nekom vrhu u drugoj komponenti, postoji i brid izme\u0111u odgovaraju\u0107ih \u017eutih vrhova."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'for (int i = 0; i < n; i++) {\n    for (int j: g[i]) {\n      if (comp[i] != comp[j]) {\n        printf("Postoji brid iz cvora %d komponente %d prema cvoru %d komponente %d\\n", i, comp[i], j, comp[j]);\n      }\n    }\n  }\n'})})]})}function j(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},6749:(e,n,a)=>{a.d(n,{A:()=>i});a(6540);var s=a(4848);const i=e=>{let{authorName:n,githubUsername:a}=e;return(0,s.jsxs)("div",{className:"author",children:["Autor: ",(0,s.jsx)("a",{target:"_blank",href:"https://github.com/"+a,children:n})]})}},8144:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/Scc-1-d9c7a93f044576fc40c79e14f093ada5.png"},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>t});var s=a(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},9630:(e,n,a)=>{a.d(n,{A:()=>r});var s=a(6540),i=a(4848);const{useState:o}=s,r=e=>{let{text:n}=e;const[a,s]=o(!1);return(0,i.jsx)("span",{onClick:()=>s(!a),className:"react-spoiler-"+(a?"shown":"hidden"),children:n})}}}]);